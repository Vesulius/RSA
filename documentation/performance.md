# Performance

Performance testing was done on prime generation as RSA algorithm requires quite large prime numbers. Primes are generated by Miller–Rabin primality test. MR -test determines whether given number is likely to be prime. 

The RSA encryption/decryption speed was not tested as the time complexity for these is O(1) and they use Javas BigInteger class so no original implementation. 


## Workings and challenges

MR -test works by generaiting random number a between 0 and tested number n. Then using a the algorithm tests if n is prime.

As the tested numbers are upto 2048 bytes there are lot of possibilites for a. The more different values for a is tested the more accurate the test is. MR -test will call composite number prime with at most 4^(-k) propability, where k is the amount of rounds.

MR -test involves a lot of randomness. To generate prime number we test random numbers until one passes the MR -test. And inside the test different a values van change how much time it takes.

This randomness will couse performance inconsistency. Lets try to insulate the problems and see how much it affects the results.


## Testing same number multiple times

Testing same number multiple times to see how much each test length varies based on the generated a value. The size of the tested number needs to be big (at least 1024 bytes) to see any clear results.

We will test primes and composites seperately. Both numbers are generated with BigInteger class.

Average time of 10 rounds to test prime number: 30.8 ms
Average time of 10 rounds to test composite number: 31.8 ms
 
```
aValueTest:
bits: 4096 rounds: 10 results are in ms
primes:
[32.0, 32.0, 32.0, 31.0, 31.0, 31.0, 31.0, 31.0, 28.0, 29.0]
composites:
[29.0, 30.0, 28.0, 34.0, 31.0, 31.0, 32.0, 32.0, 34.0, 37.0]
```

As the results show, the random a value has only couple of ms difference on the final results. The smaller the tested number the smaller the effect still and the style of measuring used is too imprecise to show any difference with smaller numbers.



## Chances of guessing prime number

There are infinite amount of prime numbers but they get increasingly rare the further we go in the positive integer space. The distubution of prime numbers approximates **N/log(N)**. This means that for integer **N** there are about **N/log(N)** prime numbers between **1** and **N**. 

What interests us is the probability of random integer being prime. Lets calculate that probability

The amount of prime numbers  between **1** and **N** is approximately **N/log(N)**.
This then must be divided by **N** to get to the the actual probability.

```
    N/log(N)/N=1/log(N)**
```

So the probability of any random integer **1** and **N** being prime is close to **1/log(N)**

From this we also find that for every doubled bit count, the probability halves.

Proof:

**2^N** has half as mady digits as **2^(2N)**. We will name **x** as the difference in probability

```
    1/log(2^N) = x * 1/log(2^(2N))
    log(2^(2N)) = x * log(2^N)
    log(2^(2N)) = log(2^(xN))
    log(2^(2N)) – log(2^(xN)) = 0
    log(2^(2N) / 2^(xN)) = 0
    2^(2N) / 2^(xN) = e^0
    2^(2N) / 2^(xN) = 1
    2^(2N) = 2^(xN)
    2N = xN
    x = 2
```

For example, the probability of random integer from 1 to 512 bit being prime is approximately 

```
    1/log(2^512) ≈ 0.0028177637517361
```

The probability of random integer from 1 to 512 bit being prime is approximately

The average number of guesses until prime number is found is

```
    x * 0.0028177637517361 = 1
    x = 1/0.0028177637517361 = 354.89135644671 ≈ 355
```

And the average number of guesses for integers from 1 to 1024 bit is

```
    1/1/log(2^1024) = log(2^1024) = 709.782712893 ≈ 710
```

Here we see that **2 * 355 = 710** as predicted.


Lets see if these calcultations hold true for our application. Here is average number of guesses and average time taken from 100 attempts with 5 rounds of MR -test.

| From 1 to X | average attempts | average time in ms |
|---|---|---|
| 2048 | 1567.34 | 2814.27 |
| 1024 | 756.82 | 274.44 |
| 512 | 332.51 | 22.0 |
| 256 | 171.75 | 2.85 |
| 128 | 73.17 | 0.46 |
| 64 | 43.06 | 0.11 |

The calculated numbers are quite close to the results. 

Frequency charts for number of guesses from 1000 attempts. Results are rounded to nearest 10 for clarity.

Searching from 1 to 1024

![attempts1024](https://github.com/Vesulius/RSA/blob/master/documentation/pictures/numOfAtt_bits1024_testRounds1000_mrRounds5.png "attempts1024")

Searching from 1 to 512

![attempts512](https://github.com/Vesulius/RSA/blob/master/documentation/pictures/numOfAtt_bits512_testRounds1000_mrRounds5.png "attempts512")

Searching from 1 to 256

![attempts256](https://github.com/Vesulius/RSA/blob/master/documentation/pictures/numOfAtt_bits256_testRounds1000_mrRounds5.png "attempts256")

As we can see all the charts 'lean' left suggesting that the median time is actually much faster than the average with some outliers taking conciderably more guesses.



## Time to complite MR -test

The average time to complete MR-test with randomly generated numbers. We will look at the prime- and composite numbers separately to see if there is any difference. Again, this must be done with big numbers (at least 2048 bytes) to see any difference with results.

```
mr-test:
bits: 2048 rounds: 10 results in ms
Average time for primes: 3.6 all data:
[4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 4.0]
Average time for composites: 3.7 all data:
[3.0, 4.0, 4.0, 4.0, 4.0, 3.0, 4.0, 3.0, 4.0, 4.0]
```

```
mr-test:
bits: 4096 rounds: 10 results in ms
Average time for primes: 27.1 all data:
[28.0, 27.0, 27.0, 28.0, 26.0, 27.0, 26.0, 28.0, 27.0, 27.0]
Average time for composites:27.4 all data
[28.0, 28.0, 27.0, 29.0, 27.0, 27.0, 26.0, 27.0, 28.0, 27.0]
```

Chart with 10 rouds average time in ms compleating MR-test:

| byte size | primes average | composite average |
|---|---|---|
| 4098 | 27.1 | 27.4 |
| 2048 | 3.6 | 3.6 |
| 1024 | 0.6 | 0.7 |

From this sample size it seems there is no clear difference between prime- and composite numbers.



## Prime generation

Now putting the tests above together and testing prime generation timing.

Chart for average time to generate prime number:

| byte size | without divideByPrimes | standard deviation | with divideByPrimes | rounds |
|---|---|---|---|---|
| 2048 | 46384.4 | 40829.0 | 3122.2 | 10 |
| 1024 | 1573.1 | 1518.7 |  134.2 | 10 |
| 512 | 160.28 | 160.0 | 16.61 | 100 |
| 256 | 23.4 | 26.1 | 4.12 | 100 |
| 128 | 5.87 | 8.2 | 0.85 | 100 |
| 64 | 1.6 | 2.8 | 1.0 | 100 |

Different rounds were used as it would takes very long to generate big numbers (for 2048 byte numbers 46384 * 100 / 1000 / 60 = 77 minutes). 

The divide by primes option simply attempts to divide the tested number by the first 100 prime numbers. If the number cannot be divided the tested number is then given to MR-test. Here we can see how much work dividing by primes quickens the process.

As we might expect from the previous frequency charts the standard deviation is very large witch means that the time to generate prime number is very unpredictable. 

For example:

```
prime generation:
bits: 2048 testRounds: 10 mrRounds: 5 divideByPrimes: false
results in ms
average: 46384.4 ms
[45346.0, 9623.0, 23238.0, 7973.0, 126762.0, 195.0, 100661.0, 55180.0, 50587.0, 44279.0]
```

Here the shortest 195 ms  ≈ 0.2 seconds and the longest one was 100661 ms ≈ 100 seconds, witch is 500 times as much. 



## Accuracy

The accuracy of MR-test is quite high. Composite number will be decleared as prime with at most probability of 1/4^k where k is the number of MR-testrounds. In reality the probability is often significantly smaller than this.

Running tests with only 1 round of testing still coundn't find false prime. 

```
Testing 10000 64 byte numbers was 100% accurate.
Testing 1000000 32 byte numbers was 100% accurate.
```